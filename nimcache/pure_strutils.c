/* Generated by Nimrod Compiler v0.9.3 */
/*   (c) 2012 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Linux, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w  -I/home/rahul/projects/Nimrod/lib -o /home/rahul/musings/nimrod/nimcache/pure_strutils.o /home/rahul/musings/nimrod/nimcache/pure_strutils.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <string.h>
typedef struct TY9352 TY9352;
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct tcell38648 tcell38648;
typedef struct tcellseq38664 tcellseq38664;
typedef struct tgcheap40616 tgcheap40616;
typedef struct tcellset38660 tcellset38660;
typedef struct tpagedesc38656 tpagedesc38656;
typedef struct tmemregion22010 tmemregion22010;
typedef struct tsmallchunk21238 tsmallchunk21238;
typedef struct tllchunk22004 tllchunk22004;
typedef struct tbigchunk21240 tbigchunk21240;
typedef struct tintset21215 tintset21215;
typedef struct ttrunk21211 ttrunk21211;
typedef struct tavlnode22008 tavlnode22008;
typedef struct tgcstat40614 tgcstat40614;
typedef struct einvalidvalue1053 einvalidvalue1053;
typedef struct esynch1029 esynch1029;
typedef struct E_Base E_Base;
typedef struct TNimObject TNimObject;
typedef struct tbasechunk21236 tbasechunk21236;
typedef struct tfreecell21228 tfreecell21228;
struct TGenericSeq {
NI len;
NI reserved;
};
typedef NIM_CHAR TY611[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY611 data;
};
typedef NU8 TY81586[32];
typedef N_NIMCALL_PTR(void, TY889) (void* p, NI op);
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
TY889 marker;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct tcell38648 {
NI Refcount;
TNimType* Typ;
};
struct tcellseq38664 {
NI Len;
NI Cap;
tcell38648** D;
};
struct tcellset38660 {
NI Counter;
NI Max;
tpagedesc38656* Head;
tpagedesc38656** Data;
};
typedef tsmallchunk21238* TY22022[512];
typedef ttrunk21211* ttrunkbuckets21213[256];
struct tintset21215 {
ttrunkbuckets21213 Data;
};
struct tmemregion22010 {
NI Minlargeobj;
NI Maxlargeobj;
TY22022 Freesmallchunks;
tllchunk22004* Llmem;
NI Currmem;
NI Maxmem;
NI Freemem;
NI Lastsize;
tbigchunk21240* Freechunkslist;
tintset21215 Chunkstarts;
tavlnode22008* Root;
tavlnode22008* Deleted;
tavlnode22008* Last;
tavlnode22008* Freeavlnodes;
};
struct tgcstat40614 {
NI Stackscans;
NI Cyclecollections;
NI Maxthreshold;
NI Maxstacksize;
NI Maxstackcells;
NI Cycletablesize;
NI64 Maxpause;
};
struct tgcheap40616 {
void* Stackbottom;
NI Cyclethreshold;
tcellseq38664 Zct;
tcellseq38664 Decstack;
tcellset38660 Cycleroots;
tcellseq38664 Tempstack;
NI Recgclock;
tmemregion22010 Region;
tgcstat40614 Stat;
};
struct TNimObject {
TNimType* m_type;
};
struct E_Base {
  TNimObject Sup;
E_Base* parent;
NCSTRING name;
NimStringDesc* message;
NimStringDesc* trace;
};
struct esynch1029 {
  E_Base Sup;
};
struct einvalidvalue1053 {
  esynch1029 Sup;
};
typedef NI TY21218[8];
struct tpagedesc38656 {
tpagedesc38656* Next;
NI Key;
TY21218 Bits;
};
struct tbasechunk21236 {
NI Prevsize;
NI Size;
NIM_BOOL Used;
};
struct tsmallchunk21238 {
  tbasechunk21236 Sup;
tsmallchunk21238* Next;
tsmallchunk21238* Prev;
tfreecell21228* Freelist;
NI Free;
NI Acc;
NF Data;
};
struct tllchunk22004 {
NI Size;
NI Acc;
tllchunk22004* Next;
};
struct tbigchunk21240 {
  tbasechunk21236 Sup;
tbigchunk21240* Next;
tbigchunk21240* Prev;
NI Align;
NF Data;
};
struct ttrunk21211 {
ttrunk21211* Next;
NI Key;
TY21218 Bits;
};
typedef tavlnode22008* TY22014[2];
struct tavlnode22008 {
TY22014 Link;
NI Key;
NI Upperbound;
NI Level;
};
struct tfreecell21228 {
tfreecell21228* Next;
NI Zerofield;
};
struct TY9352 {
  TGenericSeq Sup;
  NimStringDesc* data[SEQ_DECL_SIZE];
};
N_NIMCALL(void*, newSeq)(TNimType* typ, NI len);
N_NIMCALL(void, hiddenraiseassert_75417)(NimStringDesc* msg);
N_NOINLINE(void, raiseIndexError)(void);
static N_INLINE(NI, addInt)(NI a, NI b);
N_NOINLINE(void, raiseOverflow)(void);
static N_INLINE(NI, subInt)(NI a, NI b);
N_NIMCALL(NimStringDesc*, copyStrLast)(NimStringDesc* s, NI start_67223, NI last);
N_NIMCALL(NimStringDesc*, copyStrLast)(NimStringDesc* s, NI first, NI last);
N_NIMCALL(TGenericSeq*, incrSeq)(TGenericSeq* seq, NI elemsize);
N_NIMCALL(NimStringDesc*, copyStringRC1)(NimStringDesc* src);
static N_INLINE(void, nimGCunrefNoCycle)(void* p);
static N_INLINE(tcell38648*, usrtocell_42039)(void* usr);
static N_INLINE(void, nimFrame)(TFrame* s);
static N_INLINE(void, popFrame)(void);
static N_INLINE(void, rtladdzct_43602)(tcell38648* c);
N_NOINLINE(void, addzct_42015)(tcellseq38664* s, tcell38648* c);
N_NIMCALL(NI, npuParseInt)(NimStringDesc* s, NI* number, NI start);
N_NIMCALL(void*, newObj)(TNimType* typ, NI size);
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src);
N_NIMCALL(NimStringDesc*, rawNewString)(NI space);
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src);
N_NIMCALL(void, raiseException)(E_Base* e, NCSTRING ename);
STRING_LITERAL(TMP133, "not contains(seps, \'\\0\') ", 25);
STRING_LITERAL(TMP143, "invalid integer: ", 17);
extern TNimType NTI9352; /* seq[string] */
extern TFrame* frameptr_11825;
extern tgcheap40616 gch_40644;
extern TNimType NTI16401; /* ref EInvalidValue */
extern TNimType NTI1053; /* EInvalidValue */

static N_INLINE(NI, addInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) + (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ b));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}	LA5: ;
	raiseOverflow();	BeforeRet: ;	return result;
}
static N_INLINE(NI, subInt)(NI a, NI b) {
	NI result;
	result = 0;
	result = (NI)((NU64)(a) - (NU64)(b));
	{
		NIM_BOOL LOC3;
		LOC3 = 0;
		LOC3 = (0 <= (NI)(result ^ a));
		if (LOC3) goto LA4;
		LOC3 = (0 <= (NI)(result ^ (NI)((NU64) ~(b))));
		LA4: ;
		if (!LOC3) goto LA5;
		goto BeforeRet;
	}	LA5: ;
	raiseOverflow();	BeforeRet: ;	return result;
}
static N_INLINE(void, nimFrame)(TFrame* s) {
	(*s).prev = frameptr_11825;
	frameptr_11825 = s;
}
static N_INLINE(void, popFrame)(void) {
	frameptr_11825 = (*frameptr_11825).prev;
}
static N_INLINE(tcell38648*, usrtocell_42039)(void* usr) {
	tcell38648* result;
	nimfr("usrToCell", "gc.nim")
	result = 0;
	nimln(116, "gc.nim");
	nimln(116, "gc.nim");
	nimln(116, "gc.nim");
	result = ((tcell38648*) ((NI)((NU64)(((NI) (usr))) - (NU64)(((NI)sizeof(tcell38648))))));
	popFrame();
	return result;
}
static N_INLINE(void, rtladdzct_43602)(tcell38648* c) {
	nimfr("rtlAddZCT", "gc.nim")
	nimln(197, "gc.nim");
	addzct_42015(&gch_40644.Zct, c);	popFrame();
}
static N_INLINE(void, nimGCunrefNoCycle)(void* p) {
	tcell38648* c;
	nimfr("nimGCunrefNoCycle", "gc.nim")
	nimln(231, "gc.nim");
	c = usrtocell_42039(p);
	nimln(233, "gc.nim");
	{
		nimln(165, "gc.nim");
		(*c).Refcount -= 8;
		nimln(166, "gc.nim");
		if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA3;
		nimln(234, "gc.nim");
		rtladdzct_43602(c);	}	LA3: ;
	popFrame();
}
N_NIMCALL(TY9352*, nsuSplitCharSet)(NimStringDesc* s, TY81586 seps) {
	TY9352* result;
	NimStringDesc* x_81591;
	NI last_81624;
	nimfr("split", "strutils.nim")
	result = 0;
	nimln(1725, "system.nim");
	result = (TY9352*) newSeq((&NTI9352), 0);
	x_81591 = 0;
	nimln(212, "strutils.nim");
	last_81624 = 0;
	nimln(213, "strutils.nim");
	{
		nimln(213, "strutils.nim");
		nimln(213, "strutils.nim");
		nimln(213, "strutils.nim");
		if (!!(!(((seps[((NU8)(0))/8] &(1<<(((NU8)(0))%8)))!=0)))) goto LA3;
		nimln(213, "strutils.nim");
		hiddenraiseassert_75417(((NimStringDesc*) &TMP133));	}	LA3: ;
	nimln(214, "strutils.nim");
	while (1) {
		NI first_81626;
		nimln(214, "strutils.nim");
		nimln(214, "strutils.nim");
		if (!(last_81624 < s->Sup.len)) goto LA5;
		nimln(215, "strutils.nim");
		while (1) {
			nimln(730, "system.nim");
			if ((NU)(last_81624) > (NU)(s->Sup.len)) raiseIndexError();
			if (!((seps[((NU8)(s->data[last_81624]))/8] &(1<<(((NU8)(s->data[last_81624]))%8)))!=0)) goto LA6;
			nimln(215, "strutils.nim");
			last_81624 = addInt(last_81624, 1);
		} LA6: ;
		nimln(216, "strutils.nim");
		first_81626 = last_81624;
		nimln(217, "strutils.nim");
		while (1) {
			NIM_BOOL LOC8;
			nimln(217, "strutils.nim");
			LOC8 = 0;
			nimln(217, "strutils.nim");
			nimln(217, "strutils.nim");
			LOC8 = (last_81624 < s->Sup.len);
			if (!(LOC8)) goto LA9;
			nimln(731, "system.nim");
			nimln(731, "system.nim");
			if ((NU)(last_81624) > (NU)(s->Sup.len)) raiseIndexError();
			LOC8 = !(((seps[((NU8)(s->data[last_81624]))/8] &(1<<(((NU8)(s->data[last_81624]))%8)))!=0));
			LA9: ;
			if (!LOC8) goto LA7;
			nimln(217, "strutils.nim");
			last_81624 = addInt(last_81624, 1);
		} LA7: ;
		nimln(218, "strutils.nim");
		{
			NI TMP134;
			NI TMP135;
			NimStringDesc* LOC14;
			nimln(218, "strutils.nim");
			nimln(218, "strutils.nim");
			TMP134 = subInt(last_81624, 1);
			if (!(first_81626 <= (NI64)(TMP134))) goto LA12;
			nimln(219, "strutils.nim");
			nimln(219, "strutils.nim");
			nimln(219, "strutils.nim");
			TMP135 = subInt(last_81624, 1);
			x_81591 = copyStrLast(s, first_81626, (NI64)(TMP135));
			nimln(1726, "system.nim");
			result = (TY9352*) incrSeq(&(result)->Sup, sizeof(NimStringDesc*));
			LOC14 = 0;
			LOC14 = result->data[result->Sup.len-1]; result->data[result->Sup.len-1] = copyStringRC1(x_81591);
			if (LOC14) nimGCunrefNoCycle(LOC14);
		}		LA12: ;
	} LA5: ;
	popFrame();
	return result;
}
static N_INLINE(void, appendString)(NimStringDesc* dest, NimStringDesc* src) {
	memcpy(((NCSTRING) (&(*dest).data[((*dest).Sup.len)- 0])), ((NCSTRING) ((*src).data)), (NI64)((*src).Sup.len + 1));	(*dest).Sup.len += (*src).Sup.len;
}
static N_INLINE(void, asgnRefNoCycle)(void** dest, void* src) {
	nimfr("asgnRefNoCycle", "gc.nim")
	nimln(249, "gc.nim");
	{
		tcell38648* c;
		nimln(698, "system.nim");
		nimln(698, "system.nim");
		if (!!((src == NIM_NIL))) goto LA3;
		nimln(250, "gc.nim");
		c = usrtocell_42039(src);
		nimln(167, "gc.nim");
		(*c).Refcount += 8;
	}	LA3: ;
	nimln(252, "gc.nim");
	{
		tcell38648* c;
		nimln(698, "system.nim");
		nimln(698, "system.nim");
		if (!!(((*dest) == NIM_NIL))) goto LA7;
		nimln(253, "gc.nim");
		c = usrtocell_42039((*dest));
		nimln(254, "gc.nim");
		{
			nimln(165, "gc.nim");
			(*c).Refcount -= 8;
			nimln(166, "gc.nim");
			if (!((NU64)((*c).Refcount) < (NU64)(8))) goto LA11;
			nimln(255, "gc.nim");
			rtladdzct_43602(c);		}		LA11: ;
	}	LA7: ;
	nimln(256, "gc.nim");
	(*dest) = src;
	popFrame();
}
N_NIMCALL(NI, nsuParseInt)(NimStringDesc* s) {
	NI result;
	NI l;
	nimfr("ParseInt", "strutils.nim")
	result = 0;
	nimln(351, "strutils.nim");
	l = npuParseInt(s, &result, 0);
	nimln(352, "strutils.nim");
	{
		NIM_BOOL LOC3;
		einvalidvalue1053* e_81734;
		NimStringDesc* LOC7;
		nimln(352, "strutils.nim");
		LOC3 = 0;
		nimln(698, "system.nim");
		nimln(698, "system.nim");
		nimln(352, "strutils.nim");
		LOC3 = !((l == s->Sup.len));
		if (LOC3) goto LA4;
		nimln(352, "strutils.nim");
		LOC3 = (l == 0);
		LA4: ;
		if (!LOC3) goto LA5;
		e_81734 = 0;
		nimln(1825, "system.nim");
		e_81734 = (einvalidvalue1053*) newObj((&NTI16401), sizeof(einvalidvalue1053));
		(*e_81734).Sup.Sup.Sup.m_type = (&NTI1053);
		nimln(1826, "system.nim");
		nimln(353, "strutils.nim");
		LOC7 = 0;
		LOC7 = rawNewString(s->Sup.len + 17);
appendString(LOC7, ((NimStringDesc*) &TMP143));
appendString(LOC7, s);
		asgnRefNoCycle((void**) &(*e_81734).Sup.Sup.message, LOC7);
		nimln(353, "strutils.nim");
		raiseException((E_Base*)e_81734, "EInvalidValue");
	}	LA5: ;
	popFrame();
	return result;
}N_NOINLINE(void, purestrutilsInit)(void) {
	nimfr("strutils", "strutils.nim")
	popFrame();
}

N_NOINLINE(void, purestrutilsDatInit)(void) {
}

